* shell

A mini Nim DSL to execute shell commands more conveniently.

** Usage
With this macro you can simply write 
#+BEGIN_SRC nim
shell:
  touch foo
  mv foo bar
  rm bar
#+END_SRC
which is then rewritten to:
#+BEGIN_SRC nim
execShell("touch foo")
execShell("mv foo bar")
execShell("rm bar")
#+END_SRC
where =execShell= is a proc around =execCmdEx= (not around
=execShellCmd= in order to get the output and return value).

*Note:* By default each line in the =shell= macro will be handled by a
different call to =execShell=. If you need several commands, which
depend on the state of the previous, you may do so via the =one=
command like so:
#+BEGIN_SRC nim
shell:
  one:
    mkdir foo
    cd foo
    touch bar
    cd ".."
    rm foo/bar
#+END_SRC

Most simple things should work as expected. See below for some known quirks.

*TODO:* add support for raw string literals via accented quotes,
i.e. in =`= in order to avoid something like ~""""file""""~ if
~"file"~ is supposed to be handed to the shell.

** Known issues

Certain things unfortunately *have* to go into quotation marks. As
seen in the =one= example above, the simple =..= is not allowed. 

Also if you need assignment via =:= or ===, put it also in quotation
marks. Say you wish to compile a Nim program, you might want to do:
#+BEGIN_SRC nim
shell:
  nim c "--out:noTest" test.nim
#+END_SRC

In general, if in doubt you can just write strings or triple string
(to pass a ="= to the shell).

** Debugging
In order to see what's going on, you can either compile your program
with the =-d:debugShell= flag, which will then echo the rewritten
commands during compilation. 
Alternatively in order to avoid calling the commands immediately, you
may use the =shellEcho= macro instead. It simply echoes the commands
that would otherwise be run.
