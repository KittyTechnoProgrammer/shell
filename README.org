* shell

A mini Nim DSL to execute shell commands more conveniently.

** Usage
With this macro you can simply write 
#+BEGIN_SRC nim
shell:
  touch foo
  mv foo bar
  rm bar
#+END_SRC
which is then rewritten to:
#+BEGIN_SRC nim
execShell("touch foo")
execShell("mv foo bar")
execShell("rm bar")
#+END_SRC
where =execShell= is a proc around =execCmdEx= (not around
=execShellCmd= in order to get the output and return value).

Most simple things should work as expected. See below for some known
quirks.

** ~one~ and ~pipe~

By default each line in the =shell= macro will be handled by a
different call to =execShell=. If you need several commands, which
depend on the state of the previous, you may do so via the =one=
command like so:
#+BEGIN_SRC nim
shell:
  one:
    mkdir foo
    cd foo
    touch bar
    cd ".."
    rm foo/bar
#+END_SRC

Similar to the =one= command, the =pipe= command exists. This concats
the command via the shell pipe =|=:
#+BEGIN_SRC nim
shell:
  pipe:
    cat test.txt
    head -3
#+END_SRC
will produce:
#+BEGIN_SRC nim
execShell("cat test.txt | head -3")
#+END_SRC

Both of these can even be combined!
#+BEGIN_SRC nim
shell:
  one:
    mkdir foo
    pushd foo
    echo "Hallo\nWorld" > test.txt
    pipe:
      cat test.txt
      grep H
    popd
    rm foo/test.txt
    rmdir foo
#+END_SRC
will work just as expected, echoing =Hallo= in the shell.

** Accented quotes

Accented quotes allow you to do two different things. Raw strings and
Nim symbol quoting.

Note: this has the downside of disallowing =`= as a token to be handed
to the shell. If you want to use the shell's =`=, you need to put the
appropriate command into quotation marks.

*** Raw strings
If you want to hand a literal string to the shell, you may do so by
putting it into accented quotes:
#+BEGIN_SRC nim
echo `hello`
#+END_SRC
will be rewritten to
#+BEGIN_SRC nim
execShell("echo \"hello\"")
#+END_SRC

For a string consisting of multiple commands / words, put quotation
marks around it:
#+BEGIN_SRC sh
echo `"Hello from Nim!"`
#+END_SRC
which will then also be rewritten to:
#+BEGIN_SRC nim
execShell("echo \"Hello from Nim!\"")
#+END_SRC

*** Nim symbol quoting

Another important feature to make this library useful is quoting of
Nim symbols. In order to support this, put the Nim symbol into
accented quotes and in addition prefix it by =$= as:
#+BEGIN_SRC nim
let name = "Vindaar"
shell:
  echo Hello from `$name`
#+END_SRC 
which will perform the call:
#+BEGIN_SRC nim
execShell(&"echo Hello from {name}!")
#+END_SRC
and after the call to =strformat.&=:
#+BEGIN_SRC nim
execShell("echo Hello from Vindaar!")
#+END_SRC

** NimScript

This macro can also be used in NimScript! Instead of =execCmdEx= the
=nimscript.exec= is used.

** Known issues

Certain things unfortunately *have* to go into quotation marks. As
seen in the =one= example above, the simple =..= is not allowed. 

Variable assignments in the shell need to be handed via a string
literal:
#+BEGIN_SRC nim
shell:
  one:
    "a=`echo hello`"
    echo $a
#+END_SRC

Also if you need assignment via ':' or '=', put it also in quotation
marks. Say you wish to compile a Nim program, you might want to do:
#+BEGIN_SRC nim
shell:
  nim c "--out:noTest" test.nim
#+END_SRC

In general, if in doubt you can just write strings or triple string
(to pass a ="= to the shell).

** Debugging
In order to see what's going on, you can either compile your program
with the =-d:debugShell= flag, which will then echo the rewritten
commands during compilation. 
Alternatively in order to avoid calling the commands immediately, you
may use the =shellEcho= macro instead. It simply echoes the commands
that would otherwise be run.
